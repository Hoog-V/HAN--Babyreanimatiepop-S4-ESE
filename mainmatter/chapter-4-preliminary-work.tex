\chapter{Technical Design}
This chapter translates the functional and the architecture into technical implementation. The realisation engineering details are documented here. 

\section{Protocols Highlights}
For the details of the protocols, please consult the appendix. This section only covers the basics for understanding and to create awareness of existence.  \\
\subsection{SPI Slave protocol}
This protocol is used for the communication on the internal communicationbus of the mainboard (between the Raspberry Pi and the SAMD51).\\
\subsubsection{SPI interface}
This is the only communication bus in the manikin which utilizes a SPI data interface. SPI is a synchronous communication interface. The standard for the SPI interface specifies the rules and requirements for data transfer between devices. It provides a framework for synchronous, full-duplex communication between a master device and one or more slave devices.\\\\
With a SPI bus, communication is established between a master device (often a microcontroller) and one or more slave devices. The master device controls the communication by sending and receiving data to and from the slave devices.\\\\
The SPI bus uses a set of wires or lines for communication:\\\\
- SCLK (Serial Clock): This line carries a clock signal generated by the master device. It synchronizes the data transfer between the master and the slave devices.\\
- MOSI (Master Output, Slave Input): This line is used by the master device to send data to the slave device(s).\\
- MISO (Master Input, Slave Output): This line is used by the slave device(s) to send data back to the master device.\\
- SS/CS (Slave Select/Chip Select): This line is used to select a specific slave device for communication when multiple slaves are connected to the SPI bus. The master device activates this line for the desired slave device before sending or receiving data.\\\\
The data transfer on the SPI bus occurs in a full-duplex manner, meaning that data can be sent and received simultaneously. The master device initiates the data transfer by sending clock pulses on the SCLK line.\\ For each clock pulse, a bit of data is transferred on the MOSI line from the master to the slave, while the MISO line carries the data from the slave to the master.\\\\

\subsubsection{Slave protocol}
The SPI standard only defines the data transfer between devices but not the protocol on top. This has to be created by the manufacturer of the slave device. Therefore for this project, a slave protocol had to be built which can be implemented on the SPI interface.\\\\
The details of this protocol can be read in appendix \ref{appendix::SPI_SLAVE_PROTOCOL}. The chosen design was made with data integrity in mind. This means that both written and read bytes on the databus are validated with a maxim-CRC8 algorithm. If the integrity check fails, data can be requested using the sequence number. \\\\
The slave protocol designed looks a lot like the I2C slave protocol used between the sensor/power/actuator- hubs and the mainboard. This was by design and makes the implementation of the protocols a bit easier as the software could now be written in a more generic manner. \\
\pagebreak
\subsubsection{Features}
This protocol can be used to set and get: the sensor types, sampling rates of the sensors, status and the sensor data of the system. \\ This is done by writing and reading to the registers of the slave device (in this case sensor-, actuator- and powerhub). The registers are defined in appendix \ref{appendix::SPI_SLAVE_PROTOCOL}.

\subsection{USB Service protocol}
This protocol is used for the communication from the hubs to an external computer over (VCOM) USB.\\ This can be used in conjunction with other mentioned dataprotocols and adds another communication functionality to the hubs.\\

\subsubsection{VCOM interface}
This protocol uses the VCOM data interface, which is a virtual COM port over USB. The VCOM port can then be used like a real UART connection. Providing a lot of flexibility since we dont have to worry about the hardware side of UART. To read more about the UART connection settings for the VCOM port read appendix \ref{appendix::usb_service_protocol}.

\subsubsection{Service protocol}
To make things easier and to emulate a serial console the messages send over UART for the protocol is in plain ascii and represent abbreviated English words as commands. The usage of the service protocol is similar to the usage of a linux/unix commandline. Status and sensor readings are send in json format over the console. The left over commands return confirmations in plain text with \texttt{!ERR} for errors and \texttt{!OK}. For the full usage and explaination, take a look at appendix \ref{appendix::usb_service_protocol}.

\subsubsection{Features}
The features of this protocol are very similar to the SPI slave protocol. This protocol can be used as a replacement or in conjunction with the SPI slave protocol and will provide the same information and options. The only big difference between this and the SPI protocol is that this protocol is human comprehensible and doesn't need scripts or an application to harvest system parameters. 


\section{Engineering Decisions}
The Engineering Decisions section is meant to document crucial implementation choices which could have consequences or limitations for the future development. \\ 
This section serves as a comprehensive record of the key decisions made by the development team, providing valuable insights into the reasoning, considerations, and trade-offs that influenced the chosen path.\\\\
Lastly this is also the section for reference when an iteration, enhancements or maintenance is required or needed.
\subsection{Software Framework}
The framework used on the hubs and the mainboard use the Arduino framework. The software delivered by the previous groups was based on the Arduino framework and was non-functional. Which meant it needed a rewrite. We have considered using another framework like zephyr or Microchip ASF. \\To test these frameworks we have constructed the following requirements:\\
FrameworkSpec-1[MH] The framework has to be easy to learn/use for the beginning programmer. \\
FrameworkSpec-2[SH] The framework can be easily reconfigured to support different platforms (SAMD21/SAMD51).\\
FrameworkSpec-3[MH] The framework can be configured reliably.\\
FrameworkSpec-4[SH] The framework supports all hardware peripherals of the SAMD21/51\\
\pagebreak
\subsubsection{Microchip ASF}
Microchip ASF, also known as the Microchip Advanced Software Framework, is a collection of libraries and drivers provided by Microchip Technology. It is designed to simplify and accelerate the development of applications for Microchip microcontrollers and microprocessors. \\\\
\textbf{Advantages of Microchip ASF:} \\\\
+ \textbf{Comprehensive library support:} Microchip ASF offers a wide range of libraries that provide ready-to-use software components and drivers for various peripherals and functionalities. These libraries cover areas such as communication interfaces (e.g., UART, SPI, I2C), timers, interrupts, file systems, and more. By using these libraries, developers can save time and effort by not having to implement low-level functionality from scratch.\\ 
+ \textbf{Device abstraction and portability:} Microchip ASF provides an abstraction layer that hides the hardware details of different Microchip microcontrollers and microprocessors. This allows developers to write code that is portable across multiple devices, reducing the effort required to adapt applications to different hardware platforms. \\
+ \textbf{Integration with development tools:} Microchip ASF integrates with Microchip's development tools, including the MPLAB X IDE and MPLAB Harmony framework. \\
+ \textbf{Extensive documentation and support:} Microchip ASF is backed by comprehensive documentation and resources, including user guides, application notes, and example projects. This helps developers understand and utilize the framework effectively. Additionally, Microchip offers technical support and an active community where developers can seek assistance and share knowledge. \\\\
\textbf{Disadvantages of Microchip ASF:}\\\\
- \textbf{Learning curve and complexity:} Microchip ASF can be complex, especially for beginners or developers new to Microchip microcontrollers. The extensive range of libraries and the underlying abstraction layer may require a learning curve to understand and utilize effectively. However, the availability of documentation and support can help mitigate this challenge. \\
- \textbf{Hardware dependency:} Microchip ASF is tightly coupled with Microchip microcontrollers and microprocessors. It may not be directly compatible with other hardware platforms or microcontrollers from different manufacturers. This can limit the flexibility and portability of applications developed using ASF. \\
- \textbf{Limited customization options:} While Microchip ASF provides a wide range of pre-built libraries, customization options may be limited compared to building the software from scratch. Developers may face constraints in tailoring the software to their specific requirements or adding new features that are not supported out-of-the-box.


\pagebreak
\subsubsection{Zephyr RTOS}
Zephyr RTOS is an open-source operating system designed specifically for resource-constrained embedded systems. It provides a software framework that enables developers to build real-time applications for a wide range of devices. \\\\
\textbf{Advantages of Zephyr RTOS: }\\\\
+ \textbf{Real-time capabilities}: Zephyr RTOS is designed to handle real-time requirements, where precise timing and responsiveness are critical. It provides mechanisms for tasks and interrupts to be scheduled and executed with predictable timing, making it suitable for applications that require precise control and quick response times. \\
+ \textbf{Scalability}: Zephyr RTOS is highly scalable and can be used on a wide range of devices, from low-power microcontrollers to more powerful boards. It offers a modular architecture that allows developers to choose and configure only the components they need, optimizing resource usage and making it adaptable to different hardware platforms. \\
+ \textbf{Open-source and active community}: Zephyr RTOS is an open-source project, which means the source code is freely available for anyone to use, modify, and contribute to. It benefits from an active community of developers who collaborate, share knowledge, and provide support. This fosters continuous improvement, bug fixes, and the addition of new features. \\
Support for multiple architectures: Zephyr RTOS supports a wide range of processor architectures, including ARM, RISC-V, x86, and more. This allows developers to use the operating system on various hardware platforms, giving them flexibility and choice when selecting the right hardware for their projects. \\\\
\textbf{Disadvantages of Zephyr RTOS:} \\\\
- \textbf{Learning curve}: Zephyr RTOS may have a steeper learning curve compared to simpler frameworks like Arduino. It requires familiarity with concepts related to real-time systems, such as task scheduling, interrupts, and synchronization mechanisms. However, the availability of documentation and community support can help overcome this challenge. \\
- \textbf{Device-specific configurations}: Since Zephyr RTOS supports multiple hardware platforms, configuring and setting up the operating system for a specific device may require some effort. Device-specific configurations may involve understanding the hardware details and configuring drivers and peripherals accordingly. \\
- \textbf{Hardware limitations}: While Zephyr RTOS is highly scalable, it may not be suitable for extremely resource-constrained devices with very limited memory or processing power. The additional functionality and flexibility provided by an operating system come with some overhead in terms of memory and performance requirements.
\pagebreak
\subsubsection{Arduino}
The Arduino framework refers to the software and libraries that enable programming and interacting with Arduino boards.\\\\
\textbf{Advantages of the Arduino framework: }\\\\
+ \textbf{Simplified programming:} The Arduino framework uses a simplified programming language based on C/C++. It abstracts many low-level details and provides easy-to-use functions and libraries, making it accessible to beginners with little or no programming experience. \\
+ \textbf{Rich library ecosystem:} The Arduino framework comes with a vast library ecosystem. These libraries contain pre-written code that can be easily incorporated into the project, saving time and effort. Libraries exist for various functionalities like controlling motors, reading sensors, and communicating with other devices.\\
+ \textbf{Community support:} Arduino has a large and active community of users. This means there are numerous online resources, forums, and tutorials available where you can seek help. The community support makes it easier to overcome challenges. \\
+ \textbf{Cross-platform compatibility:} The Arduino framework is compatible with multiple operating systems, including Windows, macOS, and Linux. This allows you to work on your projects using the computer you're most comfortable with, without being restricted to a specific platform. \\\\
\textbf{Disadvantages of the Arduino framework:} \\\\
- \textbf{Limited low-level control:} The Arduino framework abstracts many low-level details to make programming easier. While this is advantageous for beginners, it can be limiting for advanced use cases which need to be tightly integrated with the underlying hardware. \\
- \textbf{Memory limitations:} Arduino boards have limited memory resources. The Arduino framework's simplicity and ease of use come at the cost of increased memory usage. This can be a constraint for projects that require complex algorithms or extensive data storage. \\
- \textbf{Hardware dependencies:} The Arduino framework is tightly integrated with Arduino boards. While this ensures compatibility and ease of use, it may not be suitable for projects that require different hardware platforms or specialized components. \\
\pagebreak
\subsubsection{Conclusion}
To help with choosing the right framework for this project we used a table with each column representing a requirement.\\
We still stuck to arduino due to the easy-entry skill needed to understand and write programs based on the arduino framework. The disadvantage of limited low-level control can be mitigated by creating low-level libraries for certain hardware peripherals. The memory limitations and hardware dependencies can be solved by having enough RAM/FLASH space and by minimizing software dependencies on arduino in the software design.

\begin{center}
\footnotesize
\begin{longtable}{|m{10em}|m{10em}|m{10em}|m{10em}|m{10em}|}
    \hline
    Framework & Dev Adaptability & Configuration & Reliability & Hardware Support \\ \hline
    Zephyr & Steep learning curve, uses non-standard way of initializing and utilizing hardware peripherals & Yes and no, When the platform is supported and all drivers used are available to the platform then yes it is easy to reconfigure. If not the case the answer is no & Yes, when used correctly it functions very reliably, gives compiler warnings when used incorrectly & No, most of the hardware functions are supported. Additional hardware drivers have to be written manually \\ \hline
    ASF & Moderate learning curve, needs knowledge of the hardware to use. & No, due to the easy to use API it is very tightly coupled, doing a lot of things under the hood which differ for each platform & No, when making mistakes this framework doesn't give any warnings and it lets the user easily misconfigure peripherals & Yes, it is written by the manufacturer of the mcu series used in this project, and supports all the hardware functions of the SAMD21/51\\ \hline
    Arduino & Beginner friendly & It is written to be cross platform and uses wrappers under the hood to provide the same functionality for each platform. & Yes, when using first-party libraries the arduino framework can be reliable. & No, it doesn't support all peripherals of the SAMD, because Arduino is written to be as generic as possible and only support features which are on the Arduino boards \\ \hline
\end{longtable}
\end{center}
\subsection{Style guide}
Requirement NF2 in chapter \ref{chapter:requirements} states that a consistent code style needs to be applied to current and new code. After a thorough look through the currently available code styles and decided to use the Google Style guide. We chose this one since it isn't too limiting for usage on embedded systems. It does still allow the usage of old c-style functions instead of the standard lib which is very resource intensive for embedded systems. And it would mix well with our testing framework which also utilizes the Google Style guide.
\subsection{Version control system}
Requirement NF3 in chapter \ref{chapter:requirements} states that the code, hardware and documentation needs to be stored in public GitHub repository's. Our project client made a GitHub Organization and gave permission to create repository's. \\\\
We created the following repository's:\\
- Manikin Software -> To store (firmware) code in for each manikin component and complementary tools (like data harvesting scripts) (SensorHub, ActuatorHub, PowerHub, scripts) \\
- Manikin Hardware -> To store all the hardware designs made by our client and previous project groups. \\
- Manikin Software Libraries -> To store loosely coupled libraries which act as wrappers or implement low level features not offered by the arduino framework. \\\\
The repository's which contain code also contain several automatically ran GitHub workflows which check the code consistency and whether the code compiles. This helps when reviewing each others code in pull requests as it gives an indication of the code quality.


